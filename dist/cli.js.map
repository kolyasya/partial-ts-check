{"version":3,"sources":["../src/cli.ts"],"sourcesContent":["#!/usr/bin/env node\nimport path from 'path';\nimport fs from 'fs';\nimport { execSync } from 'child_process';\nimport { createRequire } from 'module';\n\nconst normalize = (f: string) => f.replace(/\\\\/g, '/');\n\n// Minimal declaration to avoid requiring @types/node in this CLI\ndeclare const process: {\n  cwd(): string;\n  exit(code?: number): never;\n};\n\nconst cwd = process.cwd();\nconst requireFromCwd = createRequire(path.join(cwd, 'package.json'));\n\nfunction loadConsumerPackageJSON() {\n  const pkgPath = path.join(cwd, 'package.json');\n  const raw = fs.readFileSync(pkgPath, 'utf8');\n  return JSON.parse(raw) as {\n    partialTsChecker?: {\n      // preferred keys\n      whitelist?: string;\n      whiteList?: string;\n      blacklist?: string;\n      blackList?: string;\n      printFilesList?: boolean;\n      tsconfig?: string;\n    };\n  };\n}\n\nfunction resolveFromCwd(...segments: string[]) {\n  return path.join(cwd, ...segments);\n}\n\nfunction readList(listPath: string): string[] {\n  const abs = resolveFromCwd(listPath);\n  if (!fs.existsSync(abs)) {\n    throw new Error(`List file not found: ${listPath}`);\n  }\n  if (abs.endsWith('.js') || abs.endsWith('.cjs')) {\n    const mod = requireFromCwd(abs);\n    return (mod.default || mod) as string[];\n  }\n  const content = fs.readFileSync(abs, 'utf8');\n  try {\n    return JSON.parse(content) as string[];\n  } catch {\n    return content\n      .split(/\\r?\\n/)\n      .map((s: string) => s.trim())\n      .filter(Boolean);\n  }\n}\n\nfunction getConfig() {\n  const pkg = loadConsumerPackageJSON();\n  const cfg = pkg.partialTsChecker || {};\n  return {\n    whiteListPath:\n      cfg.whitelist || cfg.whiteList || 'app/scripts/ts-whitelist.js',\n    blackListPath:\n      cfg.blacklist || cfg.blackList || 'app/scripts/ts-blacklist.js',\n    printFilesList: cfg.printFilesList ?? true,\n    tsconfig: cfg.tsconfig || 'app/tsconfig.json',\n  } as const;\n}\n\nfunction runTsc(tsconfig: string) {\n  const tscPath = resolveFromCwd('node_modules/typescript/bin/tsc');\n  let output = '';\n  try {\n    execSync(`${tscPath} --noEmit --project ${tsconfig}`, { stdio: 'pipe' });\n    return { ok: true as const, output: '' };\n  } catch (error: any) {\n    const stdout = error.stdout?.toString() ?? '';\n    const stderr = error.stderr?.toString() ?? '';\n    output = (stdout + stderr).trim() || error.message;\n    return { ok: false as const, output };\n  }\n}\n\nfunction groupParsedByFile(\n  parsedErrors: Array<{\n    file: string;\n    line: number;\n    col: number;\n    code: string;\n    msg: string;\n  }>\n) {\n  const map = new Map<string, typeof parsedErrors>();\n  for (const e of parsedErrors) {\n    if (!map.has(e.file)) map.set(e.file, []);\n    map.get(e.file)!.push(e);\n  }\n  return map;\n}\n\nfunction main() {\n  const { whiteListPath, blackListPath, printFilesList, tsconfig } =\n    getConfig();\n  const whiteList = readList(whiteListPath);\n  const blackList = readList(blackListPath);\n\n  const { ok, output } = runTsc(tsconfig);\n  if (ok) {\n    console.log('✅ No TypeScript errors.');\n    process.exit(0);\n  }\n\n  const errorLines = output.split('\\n').filter(Boolean);\n  const nonBlacklistedErrors = errorLines\n    .filter((line) => !blackList.some((file) => line.includes(normalize(file))))\n    .filter((line) => line.trim());\n\n  const errorHeaderRegex = /^(.*?)(?:\\((\\d+),(\\d+)\\))?: error TS(\\d{4}): (.*)$/;\n  const isWhiteFile = (file: string) =>\n    whiteList.some((f) => normalize(file).includes(normalize(f)));\n\n  const parsedWhite: Array<{\n    file: string;\n    line: number;\n    col: number;\n    code: string;\n    msg: string;\n  }> = [];\n  for (const line of nonBlacklistedErrors) {\n    const m = errorHeaderRegex.exec(line);\n    if (!m) continue;\n    const file = m[1];\n    if (!isWhiteFile(file)) continue;\n    const lineNum = Number(m[2] || 0);\n    const colNum = Number(m[3] || 0);\n    const code = m[4];\n    const msg = m[5];\n    parsedWhite.push({ file, line: lineNum, col: colNum, code, msg });\n  }\n\n  if (parsedWhite.length > 0) {\n    console.error(\n      `❌ ${parsedWhite.length} TypeScript error(s) found in whitelisted files:`\n    );\n    const grouped = groupParsedByFile(parsedWhite);\n    const files = Array.from(grouped.keys()).sort();\n    const out: string[] = [];\n    for (const file of files) {\n      out.push(file);\n      const errs = grouped\n        .get(file)!\n        .sort((a, b) => a.line - b.line || a.col - b.col);\n      for (const e of errs) {\n        out.push(`  (${e.line},${e.col}): error TS${e.code}: ${e.msg}`);\n      }\n      out.push('');\n    }\n    console.error(out.join('\\n').trim());\n    process.exit(1);\n  }\n\n  console.log('✅ No TypeScript errors in whitelisted files.\\n\\n');\n\n  if (printFilesList && nonBlacklistedErrors.length > 0) {\n    const getShortErrorLine = (() => {\n      const seen = new Set<string>();\n      const tsErrorRegex = /^(.*): error TS(\\d{4})/;\n      return (line: string) => {\n        const match = line.match(tsErrorRegex);\n        if (match) {\n          const key = `${match[1]}: error TS${match[2]}`;\n          if (!seen.has(key)) {\n            seen.add(key);\n            return key;\n          }\n        }\n        return undefined;\n      };\n    })();\n\n    const sortLinesByFile = (lines: string[]) => {\n      const getFile = (line: string) =>\n        line.match(/^(.*?)(\\(\\d+,\\d+\\))?: error TS\\d{4}/)?.[1] || '';\n      return [...lines].sort((a, b) => getFile(a).localeCompare(getFile(b)));\n    };\n\n    const groupLinesByFolder = (lines: (string | undefined)[]) => {\n      const defined = lines.filter(Boolean) as string[];\n      const getFolder = (line: string) =>\n        line.match(/^(.*\\/)? .*?: error TS\\d{4}/)?.[1] || '';\n      const getFile = (line: string) =>\n        line.match(/^(.*?)(\\(\\d+,\\d+\\))?: error TS\\d{4}/)?.[1] || '';\n      let lastFolder = '',\n        lastFile = '';\n      return defined.reduce((acc: string[], line: string) => {\n        const folder = getFolder(line);\n        const file = getFile(line);\n        if (lastFolder && folder !== lastFolder) acc.push('', '');\n        else if (lastFile && file !== lastFile) acc.push('');\n        acc.push(line);\n        lastFolder = folder;\n        lastFile = file;\n        return acc;\n      }, []);\n    };\n\n    const shortErrorLines = nonBlacklistedErrors.map(getShortErrorLine);\n    const errorCount = shortErrorLines.filter(Boolean).length;\n    if (errorCount > 0) {\n      const groupedLines = groupLinesByFolder(\n        sortLinesByFile(shortErrorLines.filter(Boolean) as string[])\n      );\n      console.log(groupedLines.join('\\n'), '\\n\\n');\n      console.log(\n        `ℹ️  Found ${errorCount} TypeScript error(s) (excluding blacklisted files)`,\n        '\\n\\n'\n      );\n    }\n  }\n\n  process.exit(0);\n}\n\nmain();\n"],"mappings":"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","names":["path","fs","execSync","createRequire","normalize","f","cwd","requireFromCwd","loadConsumerPackageJSON","pkgPath","raw","resolveFromCwd","segments","readList","listPath","abs","mod","content","s","getConfig","cfg","runTsc","tsconfig","tscPath","output","error","stdout","stderr","groupParsedByFile","parsedErrors","map","e","main","whiteListPath","blackListPath","printFilesList","whiteList","blackList","ok","nonBlacklistedErrors","line","file","errorHeaderRegex","isWhiteFile","parsedWhite","m","lineNum","colNum","code","msg","grouped","files","out","errs","a","b","getShortErrorLine","seen","tsErrorRegex","match","key","sortLinesByFile","lines","getFile","groupLinesByFolder","defined","getFolder","lastFolder","lastFile","acc","folder","shortErrorLines","errorCount","groupedLines"]}