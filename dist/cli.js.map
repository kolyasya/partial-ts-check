{"version":3,"sources":["../src/lib/config.ts","../src/lib/runner.ts","../src/lib/processor.ts","../src/lib/formatter.ts","../src/cli.ts"],"sourcesContent":["import path from 'path';\nimport fs from 'fs';\nimport { createRequire } from 'module';\n\n// Default configuration paths\nexport const DEFAULT_WHITELIST_PATH = 'ts-whitelist.js';\nexport const DEFAULT_BLACKLIST_PATH = 'ts-blacklist.js';\nexport const DEFAULT_TSCONFIG_PATH = 'tsconfig.json';\n\nconst cwd = process.cwd();\nconst requireFromCwd = createRequire(path.join(cwd, 'package.json'));\n\n/**\n * Loads the consumer's package.json file.\n */\nfunction loadConsumerPackageJSON() {\n  const pkgPath = path.join(cwd, 'package.json');\n  const raw = fs.readFileSync(pkgPath, 'utf8');\n  return JSON.parse(raw) as {\n    'partial-ts-check'?: {\n      // preferred keys\n      whitelist?: string;\n      whiteList?: string;\n      blacklist?: string;\n      blackList?: string;\n      printFilesList?: boolean;\n      tsconfig?: string;\n    };\n  };\n}\n\n/**\n * Resolves a path from the current working directory.\n */\nexport function resolveFromCwd(...segments: string[]) {\n  return path.join(cwd, ...segments);\n}\n\n/**\n * Reads a list of file paths from a file.\n * The file can be a .js, .cjs, or .json file, or a plain text file with one path per line.\n */\nexport function readList(listPath: string): string[] {\n  const abs = resolveFromCwd(listPath);\n  if (!fs.existsSync(abs)) {\n    console.log(`ℹ️  List file not found: ${listPath} (will be ignored)`);\n    return [];\n  }\n  if (abs.endsWith('.js') || abs.endsWith('.cjs')) {\n    const mod = requireFromCwd(abs);\n    return (mod.default || mod) as string[];\n  }\n  const content = fs.readFileSync(abs, 'utf8');\n  try {\n    return JSON.parse(content) as string[];\n  } catch {\n    return content\n      .split(/\\r?\\n/)\n      .map((s: string) => s.trim())\n      .filter(Boolean);\n  }\n}\n\n/**\n * Gets the configuration from the consumer's package.json.\n */\nexport function getConfig() {\n  const pkg = loadConsumerPackageJSON();\n  const cfg = pkg['partial-ts-check'] || {};\n  return {\n    whiteListPath: cfg.whitelist || cfg.whiteList || DEFAULT_WHITELIST_PATH,\n    blackListPath: cfg.blacklist || cfg.blackList || DEFAULT_BLACKLIST_PATH,\n    printFilesList: cfg.printFilesList ?? true,\n    tsconfig: cfg.tsconfig || DEFAULT_TSCONFIG_PATH,\n  } as const;\n}\n","import { execSync } from 'child_process';\nimport fs from 'fs';\nimport { resolveFromCwd } from './config.js';\n\n/**\n * Runs the TypeScript compiler.\n */\nexport function runTsc(tsconfig: string) {\n  const tsconfigPath = resolveFromCwd(tsconfig);\n  if (!fs.existsSync(tsconfigPath)) {\n    console.error(`❌ TypeScript config file not found: ${tsconfig}`);\n    process.exit(1);\n  }\n\n  const tscPath = resolveFromCwd('node_modules/typescript/bin/tsc');\n  console.log(`ℹ️  Running TypeScript check with config: ${tsconfig}`);\n\n  let output = '';\n  try {\n    execSync(`${tscPath} --noEmit --project ${tsconfig}`, { stdio: 'pipe' });\n    return { ok: true as const, output: '' };\n  } catch (error: any) {\n    const stdout = error.stdout?.toString() ?? '';\n    const stderr = error.stderr?.toString() ?? '';\n    output = (stdout + stderr).trim() || error.message;\n    return { ok: false as const, output };\n  }\n}\n","import { ParsedError } from './parser.js';\n\n/**\n * Normalizes path separators to forward slashes for consistent matching.\n */\nconst normalize = (f: string) => f.replace(/\\\\/g, '/');\n\n/**\n * Filters errors based on whitelist and blacklist.\n */\nexport function filterErrors(\n  errors: string[],\n  whiteList: string[],\n  blackList: string[]\n): {\n  whitelistedErrors: ParsedError[];\n  nonWhitelistedErrors: string[];\n} {\n  const nonBlacklistedErrors = errors\n    .filter((line) => !blackList.some((file) => line.includes(normalize(file))))\n    .filter((line) => line.trim());\n\n  const errorHeaderRegex = /^(.*?)(?:\\((\\d+),(\\d+)\\))?: error TS(\\d{4}): (.*)$/;\n  const isWhiteFile = (file: string) =>\n    whiteList.some((f) => normalize(file).includes(normalize(f)));\n\n  const whitelistedErrors: ParsedError[] = [];\n  const nonWhitelistedErrors: string[] = [];\n\n  for (const line of nonBlacklistedErrors) {\n    const m = errorHeaderRegex.exec(line);\n    if (!m) {\n      nonWhitelistedErrors.push(line);\n      continue;\n    }\n    const file = m[1];\n    if (isWhiteFile(file)) {\n      const lineNum = Number(m[2] || 0);\n      const colNum = Number(m[3] || 0);\n      const code = m[4];\n      const msg = m[5];\n      whitelistedErrors.push({ file, line: lineNum, col: colNum, code, msg });\n    } else {\n      nonWhitelistedErrors.push(line);\n    }\n  }\n\n  return { whitelistedErrors, nonWhitelistedErrors };\n}\n","import { ParsedError } from './parser.js';\n\n/**\n * Groups parsed errors by file.\n */\nfunction groupParsedByFile(parsedErrors: ParsedError[]) {\n  const map = new Map<string, ParsedError[]>();\n  for (const e of parsedErrors) {\n    if (!map.has(e.file)) map.set(e.file, []);\n    map.get(e.file)!.push(e);\n  }\n  return map;\n}\n\n/**\n * Formats and prints whitelisted errors.\n */\nexport function formatWhitelistedErrors(whitelistedErrors: ParsedError[]) {\n  console.error(\n    `❌ ${whitelistedErrors.length} TypeScript error(s) found in whitelisted files:`\n  );\n  const grouped = groupParsedByFile(whitelistedErrors);\n  const files = Array.from(grouped.keys()).sort();\n  const out: string[] = [];\n  for (const file of files) {\n    out.push(file);\n    const errs = grouped\n      .get(file)!\n      .sort((a, b) => a.line - b.line || a.col - b.col);\n    for (const e of errs) {\n      out.push(`  (${e.line},${e.col}): error TS${e.code}: ${e.msg}`);\n    }\n    out.push('');\n  }\n  console.error(out.join('\\n').trim());\n}\n\n/**\n * Formats and prints non-whitelisted errors.\n */\nexport function formatNonWhitelistedErrors(nonWhitelistedErrors: string[]) {\n  const getShortErrorLine = (() => {\n    const seen = new Set<string>();\n    const tsErrorRegex = /^(.*): error TS(\\d{4})/;\n    return (line: string) => {\n      const match = line.match(tsErrorRegex);\n      if (match) {\n        const key = `${match[1]}: error TS${match[2]}`;\n        if (!seen.has(key)) {\n          seen.add(key);\n          return key;\n        }\n      }\n      return undefined;\n    };\n  })();\n\n  const sortLinesByFile = (lines: string[]) => {\n    const getFile = (line: string) =>\n      line.match(/^(.*?)(\\(\\d+,\\d+\\))?: error TS\\d{4}/)?.[1] || '';\n    return [...lines].sort((a, b) => getFile(a).localeCompare(getFile(b)));\n  };\n\n  const groupLinesByFolder = (lines: (string | undefined)[]) => {\n    const defined = lines.filter(Boolean) as string[];\n    const getFolder = (line: string) =>\n      line.match(/^(.*\\/)? .*?: error TS\\d{4}/)?.[1] || '';\n    const getFile = (line: string) =>\n      line.match(/^(.*?)(\\(\\d+,\\d+\\))?: error TS\\d{4}/)?.[1] || '';\n    let lastFolder = '',\n      lastFile = '';\n    return defined.reduce((acc: string[], line: string) => {\n      const folder = getFolder(line);\n      const file = getFile(line);\n      if (lastFolder && folder !== lastFolder) acc.push('', '');\n      else if (lastFile && file !== lastFile) acc.push('');\n      acc.push(line);\n      lastFolder = folder;\n      lastFile = file;\n      return acc;\n    }, []);\n  };\n\n  const shortErrorLines = nonWhitelistedErrors.map(getShortErrorLine);\n  const errorCount = shortErrorLines.filter(Boolean).length;\n  if (errorCount > 0) {\n    const groupedLines = groupLinesByFolder(\n      sortLinesByFile(shortErrorLines.filter(Boolean) as string[])\n    );\n    console.log(groupedLines.join('\\n'), '\\n\\n');\n    console.log(\n      `ℹ️  Found ${errorCount} TypeScript error(s) (excluding blacklisted files)`,\n      '\\n\\n'\n    );\n  }\n}\n","#!/usr/bin/env node\nimport { getConfig, readList } from './lib/config.js';\nimport { runTsc } from './lib/runner.js';\nimport { filterErrors } from './lib/processor.js';\nimport {\n  formatWhitelistedErrors,\n  formatNonWhitelistedErrors,\n} from './lib/formatter.js';\n\n// Minimal declaration to avoid requiring @types/node in this CLI\ndeclare const process: {\n  exit(code?: number): never;\n};\n\nfunction main() {\n  const { whiteListPath, blackListPath, printFilesList, tsconfig } =\n    getConfig();\n\n  console.log(`ℹ️  Loading configuration:`);\n  console.log(`  - Whitelist: ${whiteListPath}`);\n  console.log(`  - Blacklist: ${blackListPath}`);\n  console.log(`  - TypeScript config: ${tsconfig}`);\n\n  const whiteList = readList(whiteListPath);\n  const blackList = readList(blackListPath);\n\n  console.log(\n    `ℹ️  Loaded ${whiteList.length} whitelist pattern(s), ${blackList.length} blacklist pattern(s)`\n  );\n\n  const { ok, output } = runTsc(tsconfig);\n  if (ok) {\n    console.log('✅ No TypeScript errors.');\n    process.exit(0);\n  }\n\n  const errorLines = output.split('\\n').filter(Boolean);\n  const { whitelistedErrors, nonWhitelistedErrors } = filterErrors(\n    errorLines,\n    whiteList,\n    blackList\n  );\n\n  if (whitelistedErrors.length > 0) {\n    formatWhitelistedErrors(whitelistedErrors);\n    process.exit(1);\n  }\n\n  console.log('✅ No TypeScript errors in whitelisted files.\\n\\n');\n\n  if (printFilesList && nonWhitelistedErrors.length > 0) {\n    formatNonWhitelistedErrors(nonWhitelistedErrors);\n  }\n\n  process.exit(0);\n}\n\nmain();\n"],"mappings":"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","names":["path","fs","createRequire","DEFAULT_WHITELIST_PATH","DEFAULT_BLACKLIST_PATH","DEFAULT_TSCONFIG_PATH","cwd","requireFromCwd","loadConsumerPackageJSON","pkgPath","raw","resolveFromCwd","segments","readList","listPath","abs","mod","content","getConfig","cfg","execSync","fs","runTsc","tsconfig","tsconfigPath","resolveFromCwd","fs","tscPath","output","execSync","error","stdout","stderr","normalize","f","filterErrors","errors","whiteList","blackList","nonBlacklistedErrors","line","file","errorHeaderRegex","isWhiteFile","whitelistedErrors","nonWhitelistedErrors","m","lineNum","colNum","code","msg","groupParsedByFile","parsedErrors","map","e","formatWhitelistedErrors","whitelistedErrors","grouped","files","out","file","errs","a","b","formatNonWhitelistedErrors","nonWhitelistedErrors","getShortErrorLine","seen","tsErrorRegex","line","match","key","sortLinesByFile","lines","getFile","groupLinesByFolder","defined","getFolder","lastFolder","lastFile","acc","folder","shortErrorLines","errorCount","groupedLines","main","whiteListPath","blackListPath","printFilesList","tsconfig","getConfig","whiteList","readList","blackList","ok","output","runTsc","errorLines","whitelistedErrors","nonWhitelistedErrors","filterErrors","formatWhitelistedErrors","formatNonWhitelistedErrors"]}